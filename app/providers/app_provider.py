import time
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from app.common.async_iterator import AsyncIteratorWrapper
from app.providers.database import db, redis_client
from config.config import settings
from app.common.logger import TraceID, dct_llm_context, logger


def register(app):
    app.debug = settings.DEBUG
    app.title = settings.NAME

    add_global_middleware(app)

    # This hook ensures that a connection is opened to handle any queries
    # generated by the request.
    # @app.on_event("startup")
    # def startup():
    #     db.connect()

    # This hook ensures that the connection is closed when we've finished
    # processing the request.
    @app.on_event("shutdown")
    def shutdown():
        if not db.is_closed():
            db.close()

        if redis_client:
            redis_client.close()


def add_global_middleware(app):
    """
    注册全局中间件
    """
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    """
    fastapi中间件执行顺序
    请求进来时, 越先注册的中间件,越后执行. 响应出去时, 越先注册的中间件,越先执行.
    中间件接受到请求后, 可以执行后面的中间件和路径方法(), 也可以直接返回响应.
    直接返回响应则后面的方法都不再执行.
    """
    @app.middleware("http")
    async def add_process_time_header(request: Request, call_next):
        """统一在响应体里注入执行时间的字段"""
        start_time = time.time()

        # 打印request
        body = await request.body()
        # logger.info(f"Request: {request.method} {request.url} - Body: {body.decode('utf-8')[:1000]}")
        logger.info(f"Request: {request.method} {request.url.path} - Body: {body.decode('utf-8')}")

        response = await call_next(request)
        process_time = time.time() - start_time
        response.headers["X-Process-Time"] = str(process_time)

        # 打印response
        response_body = b""
        async for chunk in response.body_iterator:
            response_body += chunk
        response.body_iterator = AsyncIteratorWrapper([response_body])
        logger.info(f"Uri: {request.url.path} Response: {response.status_code} ProcessTime: {str(process_time)} - Body: {response_body.decode('utf-8')}")

        return response
    @app.middleware("http")
    async def add_context(request: Request, call_next):
        """设置上下文"""
        body = await request.body()

        _context = dct_llm_context.get()
        # print(f"上下文context字段: {_context}")
        _context['trace_id'] = TraceID.get_req_id()
        _context['request_uri'] = str(request.url.path)
        _context['request_params'] = body.decode('utf-8')

        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        _context['duration'] = str(process_time)

        # 打印response
        response_body = b""
        async for chunk in response.body_iterator:
            response_body += chunk
        response.body_iterator = AsyncIteratorWrapper([response_body])

        _context['request_response'] = response_body.decode('utf-8')
        print(f"上下文context字段: {_context}")
        # TODO: 是否需要保存日志到数据库
        return response

    @app.middleware("http")
    async def add_trace_id(request: Request, call_next):
        """设置traceId字段"""
        _trace_id = request.headers.get("x_trace_id", None)

        req_id = TraceID.set(_trace_id)
        response = await call_next(request)
        response.headers["x_trace_id"] = req_id.get()
        return response
